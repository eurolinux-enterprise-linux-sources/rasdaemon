From 0dd44fca9d756990acf01cd2cdaa585f369168bc Mon Sep 17 00:00:00 2001
From: Aristeu Rozanski <arozansk@redhat.com>
Date: Fri, 8 Apr 2016 15:07:19 -0400
Subject: [PATCH 2/2] Add Broadwell EP/EX MSCOD values

Based on mcelog commit id 32252e9c37e97ea5083d90d2cf194bb85a4a0cda.

Signed-off-by: Aristeu Rozanski <arozansk@redhat.com>
Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
---
 Makefile.am                |   3 +-
 mce-intel-broadwell-epex.c | 191 +++++++++++++++++++++++++++++++++++++++++++++
 mce-intel.c                |   3 +
 ras-mce-handler.c          |   5 +-
 ras-mce-handler.h          |   2 +
 5 files changed, 202 insertions(+), 2 deletions(-)
 create mode 100644 mce-intel-broadwell-epex.c

diff --git a/Makefile.am b/Makefile.am
index a8477d3..c9e4481 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -29,7 +29,8 @@ if WITH_MCE
 			mce-intel-p4-p6.c mce-intel-nehalem.c \
 			mce-intel-dunnington.c mce-intel-tulsa.c \
 			mce-intel-sb.c mce-intel-ivb.c mce-intel-haswell.c \
-			mce-intel-knl.c mce-intel-broadwell-de.c
+			mce-intel-knl.c mce-intel-broadwell-de.c \
+			mce-intel-broadwell-epex.c
 endif
 if WITH_EXTLOG
    rasdaemon_SOURCES += ras-extlog-handler.c
diff --git a/mce-intel-broadwell-epex.c b/mce-intel-broadwell-epex.c
new file mode 100644
index 0000000..f7cd3b6
--- /dev/null
+++ b/mce-intel-broadwell-epex.c
@@ -0,0 +1,191 @@
+/*
+ * The code below came from Tony Luck's mcelog code,
+ * released under GNU Public General License, v.2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+*/
+
+#include <string.h>
+#include <stdio.h>
+
+#include "ras-mce-handler.h"
+#include "bitfield.h"
+
+/* See IA32 SDM Vol3B Table 16-20 */
+
+static char *pcu_1[] = {
+	[0x00] = "No Error",
+	[0x09] = "MC_MESSAGE_CHANNEL_TIMEOUT",
+	[0x0D] = "MC_IMC_FORCE_SR_S3_TIMEOUT",
+	[0x0E] = "MC_CPD_UNCPD_SD_TIMEOUT",
+	[0x13] = "MC_DMI_TRAINING_TIMEOUT",
+	[0x15] = "MC_DMI_CPU_RESET_ACK_TIMEOUT",
+	[0x1E] = "MC_VR_ICC_MAX_LT_FUSED_ICC_MAX",
+	[0x25] = "MC_SVID_COMMAN_TIMEOUT",
+	[0x29] = "MC_VR_VOUT_MAC_LT_FUSED_SVID",
+	[0x2B] = "MC_PKGC_WATCHDOG_HANG_CBZ_DOWN",
+	[0x2C] = "MC_PKGC_WATCHDOG_HANG_CBZ_UP",
+	[0x39] = "MC_PKGC_WATCHDOG_HANG_C3_UP_SF",
+	[0x44] = "MC_CRITICAL_VR_FAILED",
+	[0x45] = "MC_ICC_MAX_NOTSUPPORTED",
+	[0x46] = "MC_VID_RAMP_DOWN_FAILED",
+	[0x47] = "MC_EXCL_MODE_NO_PMREQ_CMP",
+	[0x48] = "MC_SVID_READ_REG_ICC_MAX_FAILED",
+	[0x49] = "MC_SVID_WRITE_REG_VOUT_MAX_FAILED",
+	[0x4B] = "MC_BOOT_VID_TIMEOUT_DRAM_0",
+	[0x4C] = "MC_BOOT_VID_TIMEOUT_DRAM_1",
+	[0x4D] = "MC_BOOT_VID_TIMEOUT_DRAM_2",
+	[0x4E] = "MC_BOOT_VID_TIMEOUT_DRAM_3",
+	[0x4F] = "MC_SVID_COMMAND_ERROR",
+	[0x52] = "MC_FIVR_CATAS_OVERVOL_FAULT",
+	[0x53] = "MC_FIVR_CATAS_OVERCUR_FAULT",
+	[0x57] = "MC_SVID_PKGC_REQUEST_FAILED",
+	[0x58] = "MC_SVID_IMON_REQUEST_FAILED",
+	[0x59] = "MC_SVID_ALERT_REQUEST_FAILED",
+	[0x60] = "MC_INVALID_PKGS_REQ_PCH",
+	[0x61] = "MC_INVALID_PKGS_REQ_QPI",
+	[0x62] = "MC_INVALID_PKGS_RSP_QPI",
+	[0x63] = "MC_INVALID_PKGS_RSP_PCH",
+	[0x64] = "MC_INVALID_PKG_STATE_CONFIG",
+	[0x67] = "MC_HA_IMC_RW_BLOCK_ACK_TIMEOUT",
+	[0x68] = "MC_IMC_RW_SMBUS_TIMEOUT",
+	[0x69] = "MC_HA_FAILSTS_CHANGE_DETECTED",
+	[0x6A] = "MC_MSGCH_PMREQ_CMP_TIMEOUT",
+	[0x70] = "MC_WATCHDOG_TIMEOUT_PKGC_SLAVE",
+	[0x71] = "MC_WATCHDOG_TIMEOUT_PKGC_MASTER",
+	[0x72] = "MC_WATCHDOG_TIMEOUT_PKGS_MASTER",
+	[0x7C] = "MC_BIOS_RST_CPL_INVALID_SEQ",
+	[0x7D] = "MC_MORE_THAN_ONE_TXT_AGENT",
+	[0x81] = "MC_RECOVERABLE_DIE_THERMAL_TOO_HOT"
+};
+
+static struct field pcu_mc4[] = {
+	FIELD(24, pcu_1),
+	{}
+};
+
+/* See IA32 SDM Vol3B Table 16-21 */
+
+static char *qpi[] = {
+	[0x02] = "Intel QPI physical layer detected drift buffer alarm",
+	[0x03] = "Intel QPI physical layer detected latency buffer rollover",
+	[0x10] = "Intel QPI link layer detected control error from R3QPI",
+	[0x11] = "Rx entered LLR abort state on CRC error",
+	[0x12] = "Unsupported or undefined packet",
+	[0x13] = "Intel QPI link layer control error",
+	[0x15] = "RBT used un-initialized value",
+	[0x20] = "Intel QPI physical layer detected a QPI in-band reset but aborted initialization",
+	[0x21] = "Link failover data self healing",
+	[0x22] = "Phy detected in-band reset (no width change)",
+	[0x23] = "Link failover clock failover",
+	[0x30] = "Rx detected CRC error - successful LLR after Phy re-init",
+	[0x31] = "Rx detected CRC error - successful LLR wihout Phy re-init",
+};
+
+static struct field qpi_mc[] = {
+	FIELD(16, qpi),
+	{}
+};
+
+/* See IA32 SDM Vol3B Table 16-26 */
+
+static struct field memctrl_mc9[] = {
+	SBITFIELD(16, "DDR3 address parity error"),
+	SBITFIELD(17, "Uncorrected HA write data error"),
+	SBITFIELD(18, "Uncorrected HA data byte enable error"),
+	SBITFIELD(19, "Corrected patrol scrub error"),
+	SBITFIELD(20, "Uncorrected patrol scrub error"),
+	SBITFIELD(21, "Corrected spare error"),
+	SBITFIELD(22, "Uncorrected spare error"),
+	SBITFIELD(24, "iMC write data buffer parity error"),
+	SBITFIELD(25, "DDR4 command address parity error"),
+	{}
+};
+
+void broadwell_epex_decode_model(struct ras_events *ras, struct mce_event *e)
+{
+	uint64_t status = e->status;
+	uint32_t mca = status & 0xffff;
+	unsigned rank0 = -1, rank1 = -1, chan;
+
+	switch (e->bank) {
+	case 4:
+		switch (EXTRACT(status, 0, 15) & ~(1ull << 12)) {
+		case 0x402: case 0x403:
+			mce_snprintf(e->mcastatus_msg, "Internal errors ");
+			break;
+		case 0x406:
+			mce_snprintf(e->mcastatus_msg, "Intel TXT errors ");
+			break;
+		case 0x407:
+			mce_snprintf(e->mcastatus_msg, "Other UBOX Internal errors ");
+			break;
+		}
+		if (EXTRACT(status, 16, 19))
+			mce_snprintf(e->mcastatus_msg, "PCU internal error ");
+		decode_bitfield(e, status, pcu_mc4);
+		break;
+	case 5:
+	case 20:
+	case 21:
+		mce_snprintf(e->mcastatus_msg, "QPI: ");
+		decode_bitfield(e, status, qpi_mc);
+		break;
+	case 9: case 10: case 11: case 12:
+	case 13: case 14: case 15: case 16:
+		mce_snprintf(e->mcastatus_msg, "MemCtrl: ");
+		decode_bitfield(e, status, memctrl_mc9);
+		break;
+	}
+
+	/*
+	 * Memory error specific code. Returns if the error is not a MC one
+	 */
+
+	/* Check if the error is at the memory controller */
+	if ((mca >> 7) != 1)
+		return;
+
+	/* Ignore unless this is an corrected extended error from an iMC bank */
+	if (e->bank < 9 || e->bank > 16 || (status & MCI_STATUS_UC) ||
+		!test_prefix(7, status & 0xefff))
+		return;
+
+	/*
+	 * Parse the reported channel and ranks
+	 */
+
+	chan = EXTRACT(status, 0, 3);
+	if (chan == 0xf)
+		return;
+
+	mce_snprintf(e->mc_location, "memory_channel=%d", chan);
+
+	if (EXTRACT(e->misc, 62, 62)) {
+		rank0 = EXTRACT(e->misc, 46, 50);
+		if (EXTRACT(e->misc, 63, 63))
+			rank1 = EXTRACT(e->misc, 51, 55);
+	}
+
+	/*
+	 * FIXME: The conversion from rank to dimm requires to parse the
+	 * DMI tables and call failrank2dimm().
+	 */
+	if (rank0 != -1 && rank1 != -1)
+		mce_snprintf(e->mc_location, "ranks=%d and %d",
+				     rank0, rank1);
+	else if (rank0 != -1)
+		mce_snprintf(e->mc_location, "rank=%d", rank0);
+}
diff --git a/mce-intel.c b/mce-intel.c
index b132903..bf68d9b 100644
--- a/mce-intel.c
+++ b/mce-intel.c
@@ -404,6 +404,9 @@ int parse_intel_event(struct ras_events *ras, struct mce_event *e)
 	case CPU_BROADWELL_DE:
 		broadwell_de_decode_model(ras, e);
 		break;
+	case CPU_BROADWELL_EPEX:
+		broadwell_epex_decode_model(ras, e);
+		break;
 	default:
 		break;
 	}
diff --git a/ras-mce-handler.c b/ras-mce-handler.c
index b58d6e0..b875512 100644
--- a/ras-mce-handler.c
+++ b/ras-mce-handler.c
@@ -51,6 +51,7 @@ static char *cputype_name[] = {
 	[CPU_HASWELL_EPEX] = "Intel Xeon v3 (Haswell) EP/EX",
 	[CPU_BROADWELL] = "Broadwell",
 	[CPU_BROADWELL_DE] = "Broadwell DE",
+	[CPU_BROADWELL_EPEX] = "Broadwell EP/EX",
 	[CPU_KNIGHTS_LANDING] = "Knights Landing",
 };
 
@@ -93,7 +94,9 @@ static enum cputype select_intel_cputype(struct ras_events *ras)
 			return CPU_HASWELL_EPEX;
 		else if (mce->model == 0x56)
 			return CPU_BROADWELL_DE;
-		else if (mce->model == 0x3d || mce->model == 0x4f)
+		else if (mce->model == 0x4f)
+			return CPU_BROADWELL_EPEX;
+		else if (mce->model == 0x3d)
 			return CPU_BROADWELL;
 		else if (mce->model == 0x57)
 			return CPU_KNIGHTS_LANDING;
diff --git a/ras-mce-handler.h b/ras-mce-handler.h
index 2648048..c5a3717 100644
--- a/ras-mce-handler.h
+++ b/ras-mce-handler.h
@@ -46,6 +46,7 @@ enum cputype {
 	CPU_HASWELL_EPEX,
 	CPU_BROADWELL,
 	CPU_BROADWELL_DE,
+	CPU_BROADWELL_EPEX,
 	CPU_KNIGHTS_LANDING,
 };
 
@@ -123,6 +124,7 @@ void hsw_decode_model(struct ras_events *ras, struct mce_event *e);
 void knl_decode_model(struct ras_events *ras, struct mce_event *e);
 void tulsa_decode_model(struct mce_event *e);
 void broadwell_de_decode_model(struct ras_events *ras, struct mce_event *e);
+void broadwell_epex_decode_model(struct ras_events *ras, struct mce_event *e);
 
 /* Software defined banks */
 #define MCE_EXTENDED_BANK	128
-- 
1.8.3.1

