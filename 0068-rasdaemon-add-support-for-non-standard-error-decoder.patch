From 873e88d6ba1ce5ec97f5cc0f4f0b45dfd2026b9f Mon Sep 17 00:00:00 2001
From: "shiju.jose@huawei.com" <shiju.jose@huawei.com>
Date: Wed, 4 Oct 2017 10:11:08 +0100
Subject: [PATCH] rasdaemon:add support for non-standard error decoder

This patch add support to decode the non-standard
error information.

Signed-off-by: Shiju Jose <shiju.jose@huawei.com>
Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>
---
 ras-non-standard-handler.c | 62 +++++++++++++++++++++++++++++++++++++++++++++-
 ras-non-standard-handler.h | 10 ++++++++
 2 files changed, 71 insertions(+), 1 deletion(-)

diff --git a/ras-non-standard-handler.c b/ras-non-standard-handler.c
index 4c154e5..21e6a76 100644
--- a/ras-non-standard-handler.c
+++ b/ras-non-standard-handler.c
@@ -13,6 +13,7 @@
 
 #include <stdio.h>
 #include <stdlib.h>
+#include <stdbool.h>
 #include <string.h>
 #include <unistd.h>
 #include "libtrace/kbuffer.h"
@@ -21,6 +22,31 @@
 #include "ras-logger.h"
 #include "ras-report.h"
 
+static p_ns_dec_tab * ns_dec_tab;
+static size_t dec_tab_count;
+
+int register_ns_dec_tab(const p_ns_dec_tab tab)
+{
+	ns_dec_tab = (p_ns_dec_tab *)realloc(ns_dec_tab,
+					    (dec_tab_count + 1) * sizeof(tab));
+	if (ns_dec_tab == NULL) {
+		printf("%s p_ns_dec_tab malloc failed", __func__);
+		return -1;
+	}
+	ns_dec_tab[dec_tab_count] = tab;
+	dec_tab_count++;
+	return 0;
+}
+
+void unregister_ns_dec_tab(void)
+{
+	if (ns_dec_tab) {
+		free(ns_dec_tab);
+		ns_dec_tab = NULL;
+		dec_tab_count = 0;
+	}
+}
+
 void print_le_hex(struct trace_seq *s, const uint8_t *buf, int index) {
 	trace_seq_printf(s, "%02x%02x%02x%02x", buf[index+3], buf[index+2], buf[index+1], buf[index]);
 }
@@ -49,16 +75,32 @@ static char *uuid_le(const char *uu)
 	return uuid;
 }
 
+static int uuid_le_cmp(const char *sec_type, const char *uuid2)
+{
+	static char uuid1[32];
+	char *p = uuid1;
+	int i;
+	static const unsigned char le[16] = {
+			3, 2, 1, 0, 5, 4, 7, 6, 8, 9, 10, 11, 12, 13, 14, 15};
+
+	for (i = 0; i < 16; i++)
+		p += sprintf(p, "%.2x", sec_type[le[i]]);
+	*p = 0;
+	return strncmp(uuid1, uuid2, 32);
+}
+
 int ras_non_standard_event_handler(struct trace_seq *s,
 			 struct pevent_record *record,
 			 struct event_format *event, void *context)
 {
-	int len, i, line_count;
+	int len, i, line_count, count;
 	unsigned long long val;
 	struct ras_events *ras = context;
 	time_t now;
 	struct tm *tm;
 	struct ras_non_standard_event ev;
+	p_ns_dec_tab dec_tab;
+	bool dec_done = false;
 
 	/*
 	 * Newer kernels (3.10-rc1 or upper) provide an uptime clock.
@@ -133,6 +175,18 @@ int ras_non_standard_event_handler(struct trace_seq *s,
 			trace_seq_printf(s, " ");
 	}
 
+	for (count = 0; count < dec_tab_count && !dec_done; count++) {
+		dec_tab = ns_dec_tab[count];
+		for (i = 0; i < dec_tab[0].len; i++) {
+			if (uuid_le_cmp(ev.sec_type,
+					dec_tab[i].sec_type) == 0) {
+				dec_tab[i].decode(s, ev.error);
+				dec_done = true;
+				break;
+			}
+		}
+	}
+
 	/* Insert data into the SGBD */
 #ifdef HAVE_SQLITE3
 	ras_store_non_standard_record(ras, &ev);
@@ -145,3 +199,9 @@ int ras_non_standard_event_handler(struct trace_seq *s,
 
 	return 0;
 }
+
+__attribute__((destructor))
+static void ns_exit(void)
+{
+	unregister_ns_dec_tab();
+}
diff --git a/ras-non-standard-handler.h b/ras-non-standard-handler.h
index 2b5ac35..a183d1a 100644
--- a/ras-non-standard-handler.h
+++ b/ras-non-standard-handler.h
@@ -17,10 +17,20 @@
 #include "ras-events.h"
 #include "libtrace/event-parse.h"
 
+typedef struct ras_ns_dec_tab {
+	const char *sec_type;
+	int (*decode)(struct trace_seq *s, const void *err);
+	size_t len;
+} *p_ns_dec_tab;
+
 int ras_non_standard_event_handler(struct trace_seq *s,
 			 struct pevent_record *record,
 			 struct event_format *event, void *context);
 
 void print_le_hex(struct trace_seq *s, const uint8_t *buf, int index);
 
+int register_ns_dec_tab(const p_ns_dec_tab tab);
+
+void unregister_ns_dec_tab(void);
+
 #endif
-- 
1.8.3.1

