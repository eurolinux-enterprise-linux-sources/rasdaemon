From 108b124a09512d44cd810d1ef6b823c9d029d5d6 Mon Sep 17 00:00:00 2001
From: Aristeu Rozanski <arozansk@redhat.com>
Date: Mon, 18 May 2015 14:19:28 -0300
Subject: [PATCH 01/13] rasdaemon: add support for Haswell

Based on mcelog code.

Acked-by: Tony Luck <tony.luck@intel,com>
Signed-off-by: Aristeu Rozanski <arozansk@redhat.com>
Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
---
 Makefile.am         |   2 +-
 mce-intel-haswell.c | 194 ++++++++++++++++++++++++++++++++++++++++++++++++++++
 mce-intel.c         |   2 +
 ras-mce-handler.c   |   8 +++
 ras-mce-handler.h   |   3 +
 5 files changed, 208 insertions(+), 1 deletion(-)
 create mode 100644 mce-intel-haswell.c

diff --git a/Makefile.am b/Makefile.am
index 9c5f007..a6bf18f 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -28,7 +28,7 @@ if WITH_MCE
    rasdaemon_SOURCES += ras-mce-handler.c mce-intel.c mce-amd-k8.c \
 			mce-intel-p4-p6.c mce-intel-nehalem.c \
 			mce-intel-dunnington.c mce-intel-tulsa.c \
-			mce-intel-sb.c mce-intel-ivb.c
+			mce-intel-sb.c mce-intel-ivb.c mce-intel-haswell.c
 endif
 if WITH_EXTLOG
    rasdaemon_SOURCES += ras-extlog-handler.c
diff --git a/mce-intel-haswell.c b/mce-intel-haswell.c
new file mode 100644
index 0000000..c32704c
--- /dev/null
+++ b/mce-intel-haswell.c
@@ -0,0 +1,194 @@
+/*
+ * The code below came from Tony Luck mcelog code,
+ * released under GNU Public General License, v.2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+*/
+
+#include <string.h>
+#include <stdio.h>
+
+#include "ras-mce-handler.h"
+#include "bitfield.h"
+
+
+/* See IA32 SDM Vol3B Table 16-20 */
+
+static char *pcu_1[] = {
+        [0x00] = "No Error",
+        [0x09] = "MC_MESSAGE_CHANNEL_TIMEOUT",
+        [0x0D] = "MC_IMC_FORCE_SR_S3_TIMEOUT",
+        [0x0E] = "MC_CPD_UNCPD_SD_TIMEOUT",
+        [0x13] = "MC_DMI_TRAINING_TIMEOUT",
+        [0x15] = "MC_DMI_CPU_RESET_ACK_TIMEOUT",
+        [0x1E] = "MC_VR_ICC_MAX_LT_FUSED_ICC_MAX",
+        [0x25] = "MC_SVID_COMMAN_TIMEOUT",
+        [0x29] = "MC_VR_VOUT_MAC_LT_FUSED_SVID",
+        [0x2B] = "MC_PKGC_WATCHDOG_HANG_CBZ_DOWN",
+        [0x2C] = "MC_PKGC_WATCHDOG_HANG_CBZ_UP",
+        [0x39] = "MC_PKGC_WATCHDOG_HANG_C3_UP_SF",
+        [0x44] = "MC_CRITICAL_VR_FAILED",
+        [0x45] = "MC_ICC_MAX_NOTSUPPORTED",
+        [0x46] = "MC_VID_RAMP_DOWN_FAILED",
+        [0x47] = "MC_EXCL_MODE_NO_PMREQ_CMP",
+        [0x48] = "MC_SVID_READ_REG_ICC_MAX_FAILED",
+        [0x49] = "MC_SVID_WRITE_REG_VOUT_MAX_FAILED",
+        [0x4B] = "MC_BOOT_VID_TIMEOUT_DRAM_0",
+        [0x4C] = "MC_BOOT_VID_TIMEOUT_DRAM_1",
+        [0x4D] = "MC_BOOT_VID_TIMEOUT_DRAM_2",
+        [0x4E] = "MC_BOOT_VID_TIMEOUT_DRAM_3",
+        [0x4F] = "MC_SVID_COMMAND_ERROR",
+        [0x52] = "MC_FIVR_CATAS_OVERVOL_FAULT",
+        [0x53] = "MC_FIVR_CATAS_OVERCUR_FAULT",
+        [0x57] = "MC_SVID_PKGC_REQUEST_FAILED",
+        [0x58] = "MC_SVID_IMON_REQUEST_FAILED",
+        [0x59] = "MC_SVID_ALERT_REQUEST_FAILED",
+        [0x60] = "MC_INVALID_PKGS_REQ_PCH",
+        [0x61] = "MC_INVALID_PKGS_REQ_QPI",
+        [0x62] = "MC_INVALID_PKGS_RSP_QPI",
+        [0x63] = "MC_INVALID_PKGS_RSP_PCH",
+        [0x64] = "MC_INVALID_PKG_STATE_CONFIG",
+        [0x67] = "MC_HA_IMC_RW_BLOCK_ACK_TIMEOUT",
+        [0x68] = "MC_IMC_RW_SMBUS_TIMEOUT",
+        [0x69] = "MC_HA_FAILSTS_CHANGE_DETECTED",
+        [0x6A] = "MC_MSGCH_PMREQ_CMP_TIMEOUT",
+        [0x70] = "MC_WATCHDOG_TIMEOUT_PKGC_SLAVE",
+        [0x71] = "MC_WATCHDOG_TIMEOUT_PKGC_MASTER",
+        [0x72] = "MC_WATCHDOG_TIMEOUT_PKGS_MASTER",
+        [0x7C] = "MC_BIOS_RST_CPL_INVALID_SEQ",
+        [0x7D] = "MC_MORE_THAN_ONE_TXT_AGENT",
+        [0x81] = "MC_RECOVERABLE_DIE_THERMAL_TOO_HOT"
+};
+
+static struct field pcu_mc4[] = {
+        FIELD(24, pcu_1),
+        {}
+};
+
+/* See IA32 SDM Vol3B Table 16-21 */
+
+static char *qpi[] = {
+        [0x02] = "Intel QPI physical layer detected drift buffer alarm",
+        [0x03] = "Intel QPI physical layer detected latency buffer rollover",
+        [0x10] = "Intel QPI link layer detected control error from R3QPI",
+        [0x11] = "Rx entered LLR abort state on CRC error",
+        [0x12] = "Unsupported or undefined packet",
+        [0x13] = "Intel QPI link layer control error",
+        [0x15] = "RBT used un-initialized value",
+        [0x20] = "Intel QPI physical layer detected a QPI in-band reset but aborted initialization",
+        [0x21] = "Link failover data self healing",
+        [0x22] = "Phy detected in-band reset (no width change)",
+        [0x23] = "Link failover clock failover",
+        [0x30] = "Rx detected CRC error - successful LLR after Phy re-init",
+        [0x31] = "Rx detected CRC error - successful LLR wihout Phy re-init",
+};
+
+static struct field qpi_mc[] = {
+        FIELD(16, qpi),
+        {}
+};
+
+/* See IA32 SDM Vol3B Table 16-22 */
+
+static struct field memctrl_mc9[] = {
+        SBITFIELD(16, "DDR3 address parity error"),
+        SBITFIELD(17, "Uncorrected HA write data error"),
+        SBITFIELD(18, "Uncorrected HA data byte enable error"),
+        SBITFIELD(19, "Corrected patrol scrub error"),
+        SBITFIELD(20, "Uncorrected patrol scrub error"),
+        SBITFIELD(21, "Corrected spare error"),
+        SBITFIELD(22, "Uncorrected spare error"),
+        SBITFIELD(23, "Corrected memory read error"),
+        SBITFIELD(24, "iMC write data buffer parity error"),
+        SBITFIELD(25, "DDR4 command address parity error"),
+        {}
+};
+
+void hsw_decode_model(struct ras_events *ras, struct mce_event *e)
+{
+	uint64_t status = e->status;
+	uint32_t mca = status & 0xffff;
+	unsigned rank0 = -1, rank1 = -1, chan;
+
+        switch (e->bank) {
+        case 4:
+                switch (EXTRACT(status, 0, 15) & ~(1ull << 12)) {
+                case 0x402: case 0x403:
+                        /* Internal errors */
+                        break;
+                case 0x406:
+                        /* Intel TXT errors */
+                        break;
+                case 0x407:
+                        /* Other UBOX Internal errors */
+                        break;
+                }
+                if (EXTRACT(status, 16, 19))
+                        /* PCU internal error */
+                decode_bitfield(e, status, pcu_mc4);
+                break;
+        case 5:
+        case 20:
+        case 21:
+                decode_bitfield(e, status, qpi_mc);
+                break;
+        case 9: case 10: case 11: case 12:
+        case 13: case 14: case 15: case 16:
+                decode_bitfield(e, status, memctrl_mc9);
+                break;
+        }
+
+	/*
+	 * Memory error specific code. Returns if the error is not a MC one
+	 */
+
+	/* Check if the error is at the memory controller */
+	if ((mca >> 7) != 1)
+		return;
+
+	/* Ignore unless this is an corrected extended error from an iMC bank */
+	if (e->bank < 9 || e->bank > 16 || (status & MCI_STATUS_UC) ||
+		!test_prefix(7, status & 0xefff))
+		return;
+
+	/*
+	 * Parse the reported channel and ranks
+	 */
+
+	chan = EXTRACT(status, 0, 3);
+	if (chan == 0xf)
+		return;
+
+	mce_snprintf(e->mc_location, "memory_channel=%d", chan);
+
+	if (EXTRACT(e->misc, 62, 62))
+		rank0 = EXTRACT(e->misc, 46, 50);
+
+	if (EXTRACT(e->misc, 63, 63))
+		rank1 = EXTRACT(e->misc, 51, 55);
+
+	/*
+	 * FIXME: The conversion from rank to dimm requires to parse the
+	 * DMI tables and call failrank2dimm().
+	 */
+	if (rank0 >= 0 && rank1 >= 0)
+		mce_snprintf(e->mc_location, "ranks=%d and %d",
+				     rank0, rank1);
+	else if (rank0 >= 0)
+		mce_snprintf(e->mc_location, "rank=%d", rank0);
+	else
+		mce_snprintf(e->mc_location, "rank=%d", rank1);
+}
+
diff --git a/mce-intel.c b/mce-intel.c
index 427b98e..1546a1d 100644
--- a/mce-intel.c
+++ b/mce-intel.c
@@ -392,6 +392,8 @@ int parse_intel_event(struct ras_events *ras, struct mce_event *e)
 	case CPU_IVY_BRIDGE_EPEX:
 		ivb_decode_model(ras, e);
 		break;
+	case CPU_HASWELL_EPEX:
+		hsw_decode_model(ras, e);
 	default:
 		break;
 	}
diff --git a/ras-mce-handler.c b/ras-mce-handler.c
index a1d0b5d..d2de096 100644
--- a/ras-mce-handler.c
+++ b/ras-mce-handler.c
@@ -47,6 +47,8 @@ static char *cputype_name[] = {
 	[CPU_SANDY_BRIDGE_EP] = "Sandy Bridge EP",	/* Fill in better name */
 	[CPU_IVY_BRIDGE] = "Ivy Bridge",		/* Fill in better name */
 	[CPU_IVY_BRIDGE_EPEX] = "Ivy Bridge EP/EX",	/* Fill in better name */
+	[CPU_HASWELL] = "Haswell",
+	[CPU_HASWELL_EPEX] = "Intel Xeon v3 (Haswell) EP/EX",
 };
 
 static enum cputype select_intel_cputype(struct ras_events *ras)
@@ -81,6 +83,12 @@ static enum cputype select_intel_cputype(struct ras_events *ras)
 			return CPU_IVY_BRIDGE;
 		else if (mce->model == 0x3e)
 			return CPU_IVY_BRIDGE_EPEX;
+		else if (mce->model == 0x3c || mce->model == 0x45 ||
+			 mce->model == 0x46)
+			return CPU_HASWELL;
+		else if (mce->model == 0x3f)
+			return CPU_HASWELL_EPEX;
+
 		if (mce->model > 0x1a) {
 			log(ALL, LOG_INFO,
 			    "Family 6 Model %x CPU: only decoding architectural errors\n",
diff --git a/ras-mce-handler.h b/ras-mce-handler.h
index 80e9769..b8b3d4f 100644
--- a/ras-mce-handler.h
+++ b/ras-mce-handler.h
@@ -42,6 +42,8 @@ enum cputype {
 	CPU_SANDY_BRIDGE_EP,
 	CPU_IVY_BRIDGE,
 	CPU_IVY_BRIDGE_EPEX,
+	CPU_HASWELL,
+	CPU_HASWELL_EPEX,
 };
 
 struct mce_event {
@@ -114,6 +116,7 @@ void xeon75xx_decode_model(struct mce_event *e);
 void dunnington_decode_model(struct mce_event *e);
 void snb_decode_model(struct ras_events *ras, struct mce_event *e);
 void ivb_decode_model(struct ras_events *ras, struct mce_event *e);
+void hsw_decode_model(struct ras_events *ras, struct mce_event *e);
 void tulsa_decode_model(struct mce_event *e);
 
 /* Software defined banks */
-- 
1.8.3.1

